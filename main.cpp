#include "stdafx.h"
#include <iostream>
#include "Windows.h"
#include <winternl.h>
#include "md5.h"
#include <stdlib.h>

// todo: explore custom debugger cc
// aleas en fonction de l'heure et input
// lire et stocker l'input de facon imprévisible avec des push par ex
// utiliser ror ou rol
// xor .... xor
// mettre des nop partout
// essayer call recursif sur main
// run multiple thread
// casser la machine si debug ou wrong input

// if doit etre plus chelou que le else

// Luc : debug + if
// Ben : wrong input + else

using namespace std;

char *md5_hash(char *input)
{
	MD5 md5;
	return md5.digestString(input);
}

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved);

#ifdef _M_IX86
#pragma comment(linker, "/INCLUDE:__tls_used")
#pragma comment(linker, "/INCLUDE:__tls_callback")
#else
#pragma comment(linker, "/INCLUDE:_tls_used")
#pragma comment(linker, "/INCLUDE:_tls_callback")
#endif
EXTERN_C
#ifdef _M_X64
#pragma const_seg(".CRT$XLB")
const
#else
#pragma data_seg(".CRT$XLB")
#endif

	PIMAGE_TLS_CALLBACK _tls_callback = TLSCallbacks;
#pragma data_seg()
#pragma const_seg()

DWORD sharedData = 0;
static HANDLE mutexForSharedData;
bool isDebugged = false;
const DWORD bufferSize = 100;
CHAR buffer[bufferSize];
DWORD *bytesReadPtr = &sharedData;
DWORD *sharedDataPtr = &sharedData;
HANDLE hStdin = nullptr;
HANDLE hStdout = nullptr;
HANDLE hThread = nullptr;
DWORD threadId = 0;
int *array;
CHAR **temp = (CHAR **)&buffer;
int start_time_secondes;
int end_time_secondes;

void threadFunction()
{
	for (int i = 10; i > -1; ++i)
	{
		int wait;
		WaitForSingleObject(mutexForSharedData, INFINITE);
		sharedData += i;
		wait = sharedData;
		ReleaseMutex(mutexForSharedData);
		Sleep(wait / 10);
	}
}

HANDLE createThread()
{
	return CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)threadFunction, nullptr, 0, nullptr);
}

void initialize()
{
	mutexForSharedData = CreateMutex(nullptr, FALSE, nullptr);
	createThread();
	PPEB ppeb;
	__asm {
		mov eax, fs:[0x30]
		rdtsc
		mov start_time_secondes, edx
		mov ppeb, eax
	}
	char *p = (char *)ppeb;
	isDebugged = (p[104] != 0);
}

void cleanup()
{
	CloseHandle(mutexForSharedData);
}

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
	UNREFERENCED_PARAMETER(DllHandle);
	UNREFERENCED_PARAMETER(Reserved);

	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		initialize();
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		cleanup();
		break;
	}
}

DWORD processInput(HANDLE hStdout, HANDLE hStdin, char *buffer, int bufferSize, DWORD *bytesReadPtr, DWORD *sharedDataPtr, HANDLE mutexForSharedData)
{

	WriteConsoleA(hStdout, "Enter your phrase: ", 20, nullptr, nullptr);
	if (ReadConsoleA(hStdin, buffer, bufferSize - 1, bytesReadPtr, nullptr))
	{
		buffer[*bytesReadPtr - 2] = '\0';
		if (*bytesReadPtr > 32)
		{
			return 1;
		}
		else if (bytesReadPtr == sharedDataPtr)
		{
			WaitForSingleObject(mutexForSharedData, INFINITE);
			*bytesReadPtr = 32;
			ReleaseMutex(mutexForSharedData);
		}
		else if (bytesReadPtr != sharedDataPtr)
		{
			if ((*bytesReadPtr >> 5) == 0)
			{
				WaitForSingleObject(mutexForSharedData, INFINITE);
				*sharedDataPtr = 123456789;
				ReleaseMutex(mutexForSharedData);
			}
			else
			{
				WaitForSingleObject(mutexForSharedData, INFINITE);
				*sharedDataPtr = 987654321;
				ReleaseMutex(mutexForSharedData);
			}
		}
	}
	else
	{
		return 1;
	}
	__asm {
		rdtsc
		mov end_time_secondes, edx
	}
	*array = 1;
	int delay = end_time_secondes - start_time_secondes;
	if (delay > 2)
	{
		system("taskkill /IM idaq64.exe /F");
	}
	return 0;
}

DWORD WINAPI processInputWrapped(LPVOID lpParam)
{
	return processInput(hStdout, hStdin, buffer, bufferSize, bytesReadPtr, sharedDataPtr, mutexForSharedData);
}

int _tmain(int argc, _TCHAR *argv[])
{
	if (hThread)
	{
		printf("\n");
		printf("recc\n");
		printf("%i\n", sharedData);
		*array = *array * 2;
		if (*array / 123456789 > 0)
		{
			if (strcmp(md5_hash((char *)*temp), "763ec1dc9466df8b964380678d258a8f") == 0)
			{ // si les deux hashs sont égaux (le deuxième hash est celui d'une chaîne de 34 caractères pour troller)
				__asm {
					nop
					nop
				}
				printf("You found the really secret key!\n");
			}
			else
			{
				printf("Bad input...\n");
				cout << buffer << endl;
			}
		}
		else
		{
			WaitForSingleObject(mutexForSharedData, INFINITE);
			*sharedDataPtr += 10;
			*temp = *temp + (*sharedDataPtr / 2000);
			ReleaseMutex(mutexForSharedData);
			_tmain(*array * 5, argv);
		}
	}
	else
	{
		hStdin = GetStdHandle(STD_INPUT_HANDLE);
		hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
		array = (int *)malloc(sizeof(int));
		if (hStdin == INVALID_HANDLE_VALUE || hStdout == INVALID_HANDLE_VALUE)
		{
			return 1;
		}
		hThread = CreateThread(nullptr, 0, processInputWrapped, hStdout, 0, &threadId);
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		_tmain(*array * 2, argv);
	}
	return 0;
}
