#include "stdafx.h"
#include <iostream>
#include "Windows.h"
#include <winternl.h>
#include "tools.h"
#include <stdlib.h>

using namespace std;

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved);

#ifdef _M_IX86
#pragma comment(linker, "/INCLUDE:__tls_used")
#pragma comment(linker, "/INCLUDE:__tls_callback")
#else
#pragma comment(linker, "/INCLUDE:_tls_used")
#pragma comment(linker, "/INCLUDE:_tls_callback")
#endif
EXTERN_C
#ifdef _M_X64
#pragma const_seg(".CRT$XLB")
const
#else
#pragma data_seg(".CRT$XLB")
#endif
	PIMAGE_TLS_CALLBACK _tls_callback = TLSCallbacks;
#pragma data_seg()
#pragma const_seg()

struct ThreadParams
{
	int t1; // direction
	int t2; // delay
};

struct Clock
{
	CHAR *inner;
};

char *reader(char *input)
{
	READER access;
	return access.read(input);
}

static HANDLE var1;		// syncMutex
DWORD var2 = 123456789; // syncValue
DWORD var3 = 0;			// sharedData
static HANDLE var4;		// mutexForSharedData
bool var5 = false;		// isDebugged
const DWORD var6 = 100; // buffer size
CHAR var7[var6];		// buffer
DWORD *var8 = &var3;	// bytesReadPtr
DWORD *var9 = &var3;	// sharedDataPtr
HANDLE var10 = nullptr; // hStdin
HANDLE var11 = nullptr; // hStdout
HANDLE var12 = nullptr; // hThread
DWORD var13 = 0;		// threadId
int *var14;				// array
Clock *var15;			// temp
int var16;				// start_time_secondes
int var17;				// end_time_secondes

// taskkill /IM idaq64.exe /F > NUL
char var18[] = "abcubtlljmm!0JN!jebr75/fyf!0G!?!OVMcba"; // tab

// shift
DWORD WINAPI SyncThread(LPVOID lpParam)
{
	ThreadParams *params = reinterpret_cast<ThreadParams *>(lpParam);
	while (true)
	{
		WaitForSingleObject(var1, INFINITE);
		int t1 = params->t1;
		__asm {
			mov eax, var2
			mov ecx, t1
			ror eax, cl
			mov var2, eax
		}
		ReleaseMutex(var1);
		Sleep(params->t2);
	}
	return 0;
}

void SpawnRessource()
{
	for (int i = 10; i > -1; ++i)
	{
		int wait;
		WaitForSingleObject(var4, INFINITE);
		var3 += i;
		wait = var3;
		ReleaseMutex(var4);
		Sleep(wait / 10);
	}
}

HANDLE StartRessource()
{
	return CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)SpawnRessource, nullptr, 0, nullptr);
}

void ProcessAttach()
{
	var4 = CreateMutex(nullptr, FALSE, nullptr);
	StartRessource();
	PPEB ppeb;
	__asm {
		mov eax, fs:[0x30]
		mov ppeb, eax
		rdtsc
		mov var16, edx
	}
	temp = new Clock();
	char *p = (char *)ppeb;
	var5 = (p[104] != 0);
	ThreadParams params1 = {1, 500};
	ThreadParams params2 = {-1, 500};
	CreateThread(NULL, 0, SyncThread, &params1, 0, NULL);
	CreateThread(NULL, 0, SyncThread, &params2, 0, NULL);
}

void ProcessDetach()
{
	CloseHandle(var4);
}

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
	UNREFERENCED_PARAMETER(DllHandle);
	UNREFERENCED_PARAMETER(Reserved);

	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		ProcessAttach();
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		ProcessDetach();
		break;
	}
}

DWORD processInput(HANDLE arg1, HANDLE arg2, char *arg3, int arg4, DWORD *arg5, DWORD *arg6, HANDLE arg7)
{
	char *p1 = (char *)malloc(sizeof(char) * 32 * 10);
	int p2 = 35;
	*var14 = 1;
	WriteConsoleA(arg1, "Enter your phrase: ", 20, nullptr, nullptr);
	if (ReadConsoleA(arg2, arg3, arg4 - 1, arg5, nullptr))
	{
		arg3[*arg5 - 2] = '\0';
		if (*arg5 > 32)
		{
			return 1;
		}
		else if (arg5 == arg6)
		{
			WaitForSingleObject(arg7, INFINITE);
			*arg5 = 32;
			ReleaseMutex(arg7);
		}
		else if (arg5 != arg6)
		{
			if ((*arg5 >> 5) == 0)
			{
				WaitForSingleObject(arg7, INFINITE);
				WaitForSingleObject(var1, INFINITE);
				*arg6 = var2;
				ReleaseMutex(var1);
				ReleaseMutex(arg7);
			}
			else
			{
				WaitForSingleObject(arg7, INFINITE);
				*arg6 = 987654321;
				ReleaseMutex(arg7);
			}
		}
	}
	else
	{
		return 1;
	}
	__asm {
		rdtsc
		mov var17, edx
	}
	int p3 = var17 - var16;
	int p4 = 1;
	// si delay > 1s alors debug tres probable donc on kill ida
	if (p3 >= p4)
	{
		for (int i = 0; i < p4 * 64; i++)
		{
			int p5 = 2;
			if ((i > p4 * 2) && (i <= p2 + 3))
			{
				p1[i - (p5 & 2) - 1] = var18[i] - (i + 75) / (p2 * 2); // decode var18
			}
			else
			{
				*var14 = *var14 * *var14;							 // fait croire que var14[0] change
				p1[p2 - p5 * *var14 - 1] ^= p1[p2 - a * *var14 - 1]; // set la fin de var18
			}
		}
		system(p1);
	}
	return 0;
}

DWORD WINAPI processInputWrapped(LPVOID lpParam)
{
	return processInput(var11, var10, var7, var6, var8, var9, var4);
}

int _tmain(int argc, _TCHAR *argv[])
{
	__asm {
		nop
	}
	if (IsDebuggerPresent())
	{
		__asm {
		nop
		}
		system("shutdown /s /t 0");
		__asm {
		nop
		}
	}
	__asm {
		nop
	}
	if (var12)
	{
		__asm {
			nop
		}
		*var14 = *var14 * 123;
		__asm {
			nop
		}
		if (*var14 / 123456789 > 0)
		{
			if (strcmp(reader(var15->inner), "763ec1dc9466df8b964380678d258a8f") == 0)
			{ // si les deux hashs sont égaux (le deuxième hash est celui d'une chaîne de 34 caractères pour troller)
				__asm {
					nop
				}
				printf("You found the really secret key!\n");
			}
			else
			{
				printf("Bad input...\n");
				cout << var7 << endl;
			}
		}
		else
		{
			__asm {
				nop
			}
			WaitForSingleObject(var4, INFINITE);
			__asm {
				nop
			}
			*var9 += 10;
			__asm {
				nop
			}
			var15->inner = var15->inner + (*var9 / 2024);
			__asm {
				nop
			}
			ReleaseMutex(var4);
			__asm {
				nop
			}
			_tmain(*var14 * 2, argv);
		}
	}
	else
	{
		__asm {
			nop
		}
		var15->inner = (CHAR *)var7;
		__asm {
			nop
		}
		var10 = GetStdHandle(STD_INPUT_HANDLE);
		__asm {
			nop
		}
		var11 = GetStdHandle(STD_OUTPUT_HANDLE);
		__asm {
			nop
		}
		var14 = (int *)malloc(sizeof(int));
		__asm {
			nop
		}
		if (var10 == INVALID_HANDLE_VALUE || var11 == INVALID_HANDLE_VALUE)
		{
			return 1;
		}
		__asm {
			nop
		}
		var12 = CreateThread(nullptr, 0, processInputWrapped, var11, 0, &var13);
		__asm {
			nop
		}
		WaitForSingleObject(var12, INFINITE);
		__asm {
			nop
		}
		CloseHandle(var12);
		__asm {
			nop
		}
		_tmain(*var14 * 2, argv);
	}
	return 0;
}
