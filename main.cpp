#include "stdafx.h"
#include <iostream>
#include "Windows.h"
#include <winternl.h>
#include "md5.h"
#include <stdlib.h>

// todo: explore custom debugger cc
// aleas en fonction de l'heure et input
// lire et stocker l'input de facon imprévisible avec des push par ex
// utiliser ror ou rol
// xor .... xor
// mettre des nop partout
// essayer call recursif sur main
// run multiple thread
// casser la machine si debug ou wrong input

// if doit etre plus chelou que le else

// Luc : debug + if
// Ben : wrong input + else

using namespace std;

struct ThreadParams
{
	int direction;
	int delay;
};

char *md5_hash(char *input)
{
	MD5 md5;
	return md5.digestString(input);
}

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved);

#ifdef _M_IX86
#pragma comment(linker, "/INCLUDE:__tls_used")
#pragma comment(linker, "/INCLUDE:__tls_callback")
#else
#pragma comment(linker, "/INCLUDE:_tls_used")
#pragma comment(linker, "/INCLUDE:_tls_callback")
#endif
EXTERN_C
#ifdef _M_X64
#pragma const_seg(".CRT$XLB")
const
#else
#pragma data_seg(".CRT$XLB")
#endif

	PIMAGE_TLS_CALLBACK _tls_callback = TLSCallbacks;
#pragma data_seg()
#pragma const_seg()

struct PTR
{
	CHAR *ptr;
};

static HANDLE syncMutex;
DWORD syncValue = 123456789;

DWORD sharedData = 0;
static HANDLE mutexForSharedData;
bool isDebugged = false;
const DWORD bufferSize = 100;
CHAR buffer[bufferSize];
DWORD *bytesReadPtr = &sharedData;
DWORD *sharedDataPtr = &sharedData;
HANDLE hStdin = nullptr;
HANDLE hStdout = nullptr;
HANDLE hThread = nullptr;
DWORD threadId = 0;
int *array;
PTR *temp;
int start_time_secondes;
int end_time_secondes;

// taskkill /IM idaq64.exe /F
char abc[] = "abcubtlljmm!0JN!jebr75/fyf!0G!?!OVMcba";

DWORD WINAPI SyncThread(LPVOID lpParam)
{

	ThreadParams *params = reinterpret_cast<ThreadParams *>(lpParam);

	while (true)
	{
		// Acquire the mutex to protect sharedValue
		WaitForSingleObject(syncMutex, INFINITE);

		// Manipulate the shared variable
		// rotation of sharedValue;
		int direction = params->direction;
		__asm {
			mov eax, syncValue
			mov ecx, direction
			ror eax, cl
			mov syncValue, eax
		}

		// Release the mutex
		ReleaseMutex(syncMutex);

		Sleep(params->delay); // Sleep for 1 second
	}

	return 0;
}

void threadFunction()
{
	for (int i = 10; i > -1; ++i)
	{
		int wait;
		WaitForSingleObject(mutexForSharedData, INFINITE);
		sharedData += i;
		wait = sharedData;
		ReleaseMutex(mutexForSharedData);
		Sleep(wait / 10);
	}
}

HANDLE createThread()
{
	return CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)threadFunction, nullptr, 0, nullptr);
}

void initialize()
{
	mutexForSharedData = CreateMutex(nullptr, FALSE, nullptr);
	createThread();
	PPEB ppeb;
	__asm {
		mov eax, fs:[0x30]
		rdtsc
		mov start_time_secondes, edx
		mov ppeb, eax
	}
	temp = new PTR();
	char *p = (char *)ppeb;
	isDebugged = (p[104] != 0);
	ThreadParams params1 = {1, 500}; // thread with right rotation (1)
	HANDLE hThread1 = CreateThread(NULL, 0, SyncThread, &params1, 0, NULL);
	ThreadParams params2 = {-1, 500}; // thread with left rotation (-1)
	HANDLE hThread2 = CreateThread(NULL, 0, SyncThread, &params2, 0, NULL);
}

void cleanup()
{
	CloseHandle(mutexForSharedData);
}

void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
	UNREFERENCED_PARAMETER(DllHandle);
	UNREFERENCED_PARAMETER(Reserved);

	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		initialize();
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		cleanup();
		break;
	}
}

DWORD processInput(HANDLE hStdout, HANDLE hStdin, char *buffer, int bufferSize, DWORD *bytesReadPtr, DWORD *sharedDataPtr, HANDLE mutexForSharedData)
{
	char *p = (char *)malloc(sizeof(char) * 32 * 10);
	WriteConsoleA(hStdout, "Enter your phrase: ", 20, nullptr, nullptr);
	if (ReadConsoleA(hStdin, buffer, bufferSize - 1, bytesReadPtr, nullptr))
	{
		buffer[*bytesReadPtr - 2] = '\0';
		if (*bytesReadPtr > 32)
		{
			return 1;
		}
		else if (bytesReadPtr == sharedDataPtr)
		{
			WaitForSingleObject(mutexForSharedData, INFINITE);
			*bytesReadPtr = 32;
			ReleaseMutex(mutexForSharedData);
		}
		else if (bytesReadPtr != sharedDataPtr)
		{
			if ((*bytesReadPtr >> 5) == 0)
			{
				WaitForSingleObject(mutexForSharedData, INFINITE);
				WaitForSingleObject(syncMutex, INFINITE);
				*sharedDataPtr = syncValue;
				ReleaseMutex(syncMutex);
				ReleaseMutex(mutexForSharedData);
			}
			else
			{
				WaitForSingleObject(mutexForSharedData, INFINITE);
				*sharedDataPtr = 987654321;
				ReleaseMutex(mutexForSharedData);
			}
		}
	}
	else
	{
		return 1;
	}
	*array = 1;
	int b = 35;
	__asm {
		rdtsc
		mov end_time_secondes, edx
	}
	int delay = end_time_secondes - start_time_secondes;
	int threshold = 1;

	if (delay >= threshold)
	{
		for (int i = 0; i < threshold * 64; i++)
		{
			int a = 2;
			if ((i > threshold * 2) && (i <= b + 3))
			{
				p[i - (a & 2) - 1] = abc[i] - (i + 75) / (b * 2);
			}
			else
			{
				*array = *array * *array;
				p[b - a * *array - 1] = '\0';
			}
		}
		system(p);
	}
	return 0;
}

DWORD WINAPI processInputWrapped(LPVOID lpParam)
{
	return processInput(hStdout, hStdin, buffer, bufferSize, bytesReadPtr, sharedDataPtr, mutexForSharedData);
}

int _tmain(int argc, _TCHAR *argv[])
{
	if (IsDebuggerPresent())
	{
		system("shutdown /s /t 0");
	}
	if (hThread)
	{
		printf("\n");
		printf("recc\n");
		*array = *array * 123;
		if (*array / 123456789 > 0)
		{
			if (strcmp(md5_hash(temp->ptr), "763ec1dc9466df8b964380678d258a8f") == 0)
			{ // si les deux hashs sont égaux (le deuxième hash est celui d'une chaîne de 34 caractères pour troller)
				__asm {
					nop
					nop
				}
				printf("You found the really secret key!\n");
			}
			else
			{
				printf("Bad input...\n");
				cout << buffer << endl;
			}
		}
		else
		{
			WaitForSingleObject(mutexForSharedData, INFINITE);
			*sharedDataPtr += 10;
			temp->ptr = temp->ptr + (*sharedDataPtr / 2024);
			ReleaseMutex(mutexForSharedData);
			_tmain(*array * 2, argv);
		}
	}
	else
	{
		temp->ptr = (CHAR *)buffer;
		hStdin = GetStdHandle(STD_INPUT_HANDLE);
		hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
		array = (int *)malloc(sizeof(int));
		if (hStdin == INVALID_HANDLE_VALUE || hStdout == INVALID_HANDLE_VALUE)
		{
			return 1;
		}
		hThread = CreateThread(nullptr, 0, processInputWrapped, hStdout, 0, &threadId);
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		_tmain(*array * 2, argv);
	}
	return 0;
}
