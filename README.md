# Malware Analysis

> Benjamin DUMONT & Luc NICAUD

- Code source et exécutable de notre malware
- Diapo de notre analyse du malware du trinôme Filbert, Ulrichka et André

## Code source

Le code source de notre malware est disponible dans le fichier `DUMONT_NICAUD_malware.cpp`

Il a été compilé avec le fichier d'entête `tools.h` en mode release avec visual studio sur la machine virtuelle du cours.

## Fonctionnement du malware

Le programme renvoie toujours l'input si aucun debugger n'est détecté.

Un test est effectué entre l'input et le hash md5 `763ec1dc9466df8b964380678d258a8f` d'un mot-de-passe qui a une taille de 34 caractères. Ce mot-de-passe "impossible" sert à donner l'illusion qu'on est dans la catégorie d'un méchant malware.

Le programme lance 3 Thread au démarrage.

Le premier SpawnRessource incrémente une variable globale à chaque itération. Si cette variable augmente trop, c'est-à-dire si le programme tourne trop longtemps, on suspect un débuggage en cours et le programme va problament crash à la ligne 258.

Le deuxième et troisième Thread run la fonction SyncThread et alterne var1. C'est thread sont uniquement là pour ralentir le programme et rendre le débuggage plus difficile.

La particularité du programme est de faire un appel à main récursif, pour rendre confus le graphe du code.
On arrete la recursion sur main quand \*var14 / 123456789 > 0

La variable var15 contient la chaine en input.
On compare ensuite si strcmp(reader(var15->inner), "763ec1dc9466df8b964380678d258a8f") == 0, ce qui est toujours faux. On ne rentre donc jamais dans le if. Et on renvoie input.

Les lignes 200 à 218 sont des lignes qui permettent de calculer le temps d'exécution du programme depuis le tls ligne 120. Le temps est calculé à l'aide de RDTSC.
Si le temps est trop long, on suspect un débuggage et on essaye de kill IDA en décodant la chaine abcubtlljmm!0JN!jebr75/fyf!0G!2?!ovm!3?ovmcba en taskkill /IM idaq64.exe /F > NUL

La fonction main a plein d'instructions nop qui ne font rien.
