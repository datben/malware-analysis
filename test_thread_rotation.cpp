#include "stdafx.h"
#include <iostream>
#include "Windows.h"


// Structure to hold parameters for the thread function
struct ThreadParams {
    int direction;
    int delay;
};

// Global variable shared by both threads
int sharedValue = 1453;
HANDLE mutex;  // Mutex to synchronize access to sharedValue

// Function to be executed by the thread
DWORD WINAPI ThreadFunction(LPVOID lpParam) {

	ThreadParams* params = reinterpret_cast<ThreadParams*>(lpParam);

    for (int i = 0; i < 5; ++i) {
        // Acquire the mutex to protect sharedValue
        WaitForSingleObject(mutex, INFINITE);

        // Manipulate the shared variable
        //rotation of sharedValue;
		int direction = params->direction;
		__asm{
			mov eax, sharedValue
			mov ecx, direction
			ror eax, cl
			mov sharedValue, eax
		}
        std::cout << "Thread: " << GetCurrentThreadId() << " - Shared Counter: " << sharedValue << std::endl;

        // Release the mutex
        ReleaseMutex(mutex);

        Sleep(params->delay); // Sleep for 1 second
    }

    return 0;
}

int main() {
    // Create a mutex
    mutex = CreateMutex(NULL, FALSE, NULL);

    if (mutex == NULL) {
        std::cerr << "Failed to create mutex." << std::endl;
        return 1;
    }

    // Create two threads
	ThreadParams params1 = {1, 1000}; // thread with right rotation (1)
    HANDLE hThread1 = CreateThread(NULL, 0, ThreadFunction, &params1, 0, NULL);
	ThreadParams params2 = {-1, 1000}; // thread with left rotation (-1)
    HANDLE hThread2 = CreateThread(NULL, 0, ThreadFunction, &params2, 0, NULL);
	// If synchronized, the threads are neutralized. Change one of the delay value to create desync (debugger presence ?)

    if (hThread1 == NULL || hThread2 == NULL) {
        std::cerr << "Failed to create threads." << std::endl;
        CloseHandle(mutex);
        return 1;
    }

    // Wait for both threads to finish
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    // Close the thread handles and the mutex
    CloseHandle(hThread1);
    CloseHandle(hThread2);
    CloseHandle(mutex);

    std::cout << "All threads exited." << std::endl;

	while(1);
    return 0;
}